import React, { useState, useEffect } from 'react';
import { motion, AnimatePresence } from 'framer-motion';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { usePageStore } from '../../stores/pageStore';
import { useTheme } from 'next-themes';

// Components
import PageHeader from './PageHeader';
import PageCover from './PageCover';
import PageContent from './PageContent';
import PageHistory from './PageHistory';
import PageSettings from './PageSettings';
import Notification from '../shared/Notification';
import LoadingSpinner from '../shared/LoadingSpinner';
import BottomToolbar from './BottomToolbar';

// Services
import { getPageContent, savePage, restorePageVersion } from '../../services/pageContentService';

// Animations
import { fadeVariants, containerVariants } from '../../utils/animations';

const PageComponent = ({ workspaceId, initialPage = null }) => {
  const queryClient = useQueryClient();
  const { theme } = useTheme();

  // State cá»¥c bá»™ cho blocks
  const [blocks, setBlocksLocal] = useState([]);

  // CÃ¡c giÃ¡ trá»‹ khÃ¡c tá»« store
  const page = usePageStore((state) => state.page);
  const saving = usePageStore((state) => state.saving);
  const notification = usePageStore((state) => state.notification);
  const selectedTab = usePageStore((state) => state.selectedTab);
  const isStarred = usePageStore((state) => state.isStarred);

  const setPage = usePageStore((state) => state.setPage);
  const setSaving = usePageStore((state) => state.setSaving);
  const setNotification = usePageStore((state) => state.setNotification);
  const setSelectedTab = usePageStore((state) => state.setSelectedTab);
  const toggleStar = usePageStore((state) => state.toggleStar);

  // Fetch page data using React Query
  const { isLoading, refetch } = useQuery({
    queryKey: ['pageContent', initialPage?.id],
    queryFn: () => {
      if (!initialPage?.id) {
        throw new Error('Page ID is missing');
      }
      return getPageContent(initialPage.id);
    },
    enabled: !!initialPage?.id,
    onSuccess: (data) => {
      console.log('Page content fetched:', data);
      if (!data) {
        console.error('No data received from getPageContent');
        setNotification({
          type: 'error',
          message: 'No page content received',
        });
        setBlocksLocal([]);
        return;
      }

      console.log('Raw blocks from server:', data.blocks);
      const blocksData = Array.isArray(data.blocks)
        ? data.blocks.map((block, index) => {
            console.log('Processing block:', block);
            if (typeof block === 'string') {
              return { id: block, content: '', type: 'text', position: index };
            }
            const blockData = {
              id: block._id || block.id || `temp-${index}`,
              content: block.content || '',
              type: block.type || 'text',
              position: block.position ?? index,
            };
            console.log('Mapped block:', blockData);
            return blockData;
          })
        : [];

      console.log('Blocks data prepared:', blocksData);
      setBlocksLocal(blocksData);
      console.log('Blocks after setBlocksLocal:', blocksData);
    },
    onError: (error) => {
      console.error('Failed to fetch page content:', error);
      setNotification({
        type: 'error',
        message: `Failed to load page content: ${error.message}`,
      });
      setBlocksLocal([]);
    },
  });

  useEffect(() => {
    if (initialPage && !page?.id) {
      console.log('Initializing page with:', initialPage);
      setPage({
        id: initialPage.id,
        title: initialPage.title || 'Untitled',
        icon: initialPage.icon || 'ðŸ“„',
        coverUrl: initialPage.coverUrl || '',
        isPublic: initialPage.isPublic || false,
      });
    }
  }, [initialPage, setPage]);

  const handleSave = () => {
    saveMutation.mutate({ pageData: page, blocks });
  };

  const saveMutation = useMutation({
    mutationFn: ({ pageData, blocks }) => savePage(pageData, blocks),
    onMutate: () => setSaving(true),
    onSuccess: () => {
      setSaving(false);
      setNotification({
        type: 'success',
        message: 'Page saved successfully',
      });
      queryClient.invalidateQueries(['pageContent', initialPage?.id]);
    },
    onError: (error) => {
      setSaving(false);
      setNotification({
        type: 'error',
        message: 'Failed to save page',
      });
    },
  });

  const handleRestore = async (version) => {
    try {
      await restorePageVersion(initialPage.id, version);
      console.log('Restore successful, refetching data...');
      const result = await refetch({ throwOnError: true });
      console.log('Refetched data after restore:', result);
      if (!result.data || !Array.isArray(result.data.blocks)) {
        throw new Error('Invalid data after restore');
      }
      const newBlocks = result.data.blocks.map((block, index) => ({
        ...block,
        id: block._id || block.id || `temp-${index}`,
      }));
      setBlocksLocal(newBlocks);
      console.log('Blocks after restore:', newBlocks);
      setNotification({
        type: 'success',
        message: `Restored to version ${version}`,
      });
    } catch (error) {
      console.error('Failed to restore version:', error);
      setNotification({
        type: 'error',
        message: 'Failed to restore version',
      });
    }
  };

  const renderTabContent = () => {
    switch (selectedTab) {
      case 'content':
        return <PageContent />;
      case 'history':
        return <PageHistory onRestore={handleRestore} />;
      case 'settings':
        return <PageSettings onSave={handleSave} />;
      default:
        return null;
    }
  };

  console.log('Rendering with states:', { isLoading, blocks });

  if (isLoading) {
    return <LoadingSpinner />;
  }

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900 transition-colors duration-200">
      <PageHeader
        onSave={handleSave}
        saving={saving}
        isStarred={isStarred}
        toggleStar={toggleStar}
      />
      <AnimatePresence>
        {notification && (
          <Notification
            type={notification.type}
            message={notification.message}
            onClose={() => setNotification(null)}
          />
        )}
      </AnimatePresence>
      <main className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 pb-16">
        {page.coverUrl && <PageCover />}
        <motion.div
          className="flex border-b border-gray-200 dark:border-gray-700 mt-8"
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ delay: 0.3 }}
        >
          <button
            className={`px-4 py-2 font-medium text-sm ${selectedTab === 'content' ? 'text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700'}`}
            onClick={() => setSelectedTab('content')}
          >
            Content
          </button>
          <button
            className={`px-4 py-2 font-medium text-sm ${selectedTab === 'history' ? 'text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700'}`}
            onClick={() => setSelectedTab('history')}
          >
            History
          </button>
          <button
            className={`px-4 py-2 font-medium text-sm ${selectedTab === 'settings' ? 'text-indigo-600 dark:text-indigo-400 border-b-2 border-indigo-600' : 'text-gray-500 dark:text-gray-400 hover:text-gray-700'}`}
            onClick={() => setSelectedTab('settings')}
          >
            Settings
          </button>
        </motion.div>
        <div className="mt-6">{renderTabContent()}</div>
      </main>
      <BottomToolbar />
    </div>
  );
};

export default PageComponent;